/* automatically generated by rust-bindgen 0.69.4 */

pub trait LibOTCryptoMAC<
    ID: ::encapfn::branding::EFID,
    RT: ::encapfn::rt::EncapfnRt<ID = ID>,
    ABI = <RT as ::encapfn::rt::EncapfnRt>::ABI,
>
{
    type RT: ::encapfn::rt::EncapfnRt;
    fn rt(&self) -> &Self::RT;
    fn otcrypto_hmac_init(
        &self,
        ctx: *mut hmac_context_t,
        key: *const crypto_blinded_key_t,
        access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<crypto_status_t>;
    fn otcrypto_hmac_update(
        &self,
        ctx: *mut hmac_context_t,
        input_message: crypto_const_byte_buf_t,
        access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<crypto_status_t>;
    fn otcrypto_hmac_final(
        &self,
        ctx: *mut hmac_context_t,
        tag: *mut crypto_word32_buf_t,
        access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<crypto_status_t>;
    fn keyblob_num_words(
        &self,
        config: crypto_key_config_t,
        access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<usize>;
    fn keyblob_from_key_and_mask(
        &self,
        key: *const u32,
        mask: *const u32,
        config: crypto_key_config_t,
        keyblob: *mut u32,
        access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<status_t>;
    fn integrity_blinded_checksum(
        &self,
        key: *const crypto_blinded_key_t,
        access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<u32>;
}
pub const LibOTCryptoMACFntab: [&'static ::core::ffi::CStr; 6usize] = [
    c"keyblob_num_words",
    c"keyblob_from_key_and_mask",
    c"otcrypto_hmac_update",
    c"otcrypto_hmac_init",
    c"otcrypto_hmac_final",
    c"integrity_blinded_checksum",
];
pub const LibOTCryptoMACFixedFntab: [Option<&'static ::core::ffi::CStr>; 6usize] = [
    Some(c"keyblob_num_words"),
    Some(c"keyblob_from_key_and_mask"),
    Some(c"integrity_blinded_checksum"),
    Some(c"otcrypto_hmac_init"),
    Some(c"otcrypto_hmac_update"),
    Some(c"otcrypto_hmac_final"),
];
pub struct LibOTCryptoMACRt<'a, ID: ::encapfn::branding::EFID, RT: ::encapfn::rt::EncapfnRt> {
    rt: &'a RT,
    symbols: RT::SymbolTableState<6usize, 6usize>,
    _id: ::core::marker::PhantomData<ID>,
}
impl<'a, ID: ::encapfn::branding::EFID, RT: ::encapfn::rt::EncapfnRt> LibOTCryptoMACRt<'a, ID, RT> {
    pub fn new(rt: &'a RT) -> Option<Self> {
        if let Some(symbols) = rt.resolve_symbols(&LibOTCryptoMACFntab, &LibOTCryptoMACFixedFntab) {
            Some(LibOTCryptoMACRt {
                rt: rt,
                symbols,
                _id: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}
impl<ID: ::encapfn::branding::EFID>
    LibOTCryptoMAC<ID, ::encapfn::rt::mock::MockRt<ID>, ::encapfn::abi::GenericABI>
    for LibOTCryptoMACRt<'_, ID, ::encapfn::rt::mock::MockRt<ID>>
{
    type RT = ::encapfn::rt::mock::MockRt<ID>;
    fn rt(&self) -> &Self::RT {
        &self.rt
    }
    fn otcrypto_hmac_init(
        &self,
        ctx: *mut hmac_context_t,
        key: *const crypto_blinded_key_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<crypto_status_t> {
        ::encapfn::EFResult::Ok(::encapfn::types::EFCopy::new(unsafe {
            self::otcrypto_hmac_init(ctx, key)
        }))
    }
    fn otcrypto_hmac_update(
        &self,
        ctx: *mut hmac_context_t,
        input_message: crypto_const_byte_buf_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<crypto_status_t> {
        ::encapfn::EFResult::Ok(::encapfn::types::EFCopy::new(unsafe {
            self::otcrypto_hmac_update(ctx, input_message)
        }))
    }
    fn otcrypto_hmac_final(
        &self,
        ctx: *mut hmac_context_t,
        tag: *mut crypto_word32_buf_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<crypto_status_t> {
        ::encapfn::EFResult::Ok(::encapfn::types::EFCopy::new(unsafe {
            self::otcrypto_hmac_final(ctx, tag)
        }))
    }
    fn keyblob_num_words(
        &self,
        config: crypto_key_config_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<usize> {
        ::encapfn::EFResult::Ok(::encapfn::types::EFCopy::new(unsafe {
            self::keyblob_num_words(config)
        }))
    }
    fn keyblob_from_key_and_mask(
        &self,
        key: *const u32,
        mask: *const u32,
        config: crypto_key_config_t,
        keyblob: *mut u32,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<status_t> {
        ::encapfn::EFResult::Ok(::encapfn::types::EFCopy::new(unsafe {
            self::keyblob_from_key_and_mask(key, mask, config, keyblob)
        }))
    }
    fn integrity_blinded_checksum(
        &self,
        key: *const crypto_blinded_key_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<u32> {
        ::encapfn::EFResult::Ok(::encapfn::types::EFCopy::new(unsafe {
            self::integrity_blinded_checksum(key)
        }))
    }
}
trait LibOTCryptoMACSysVAMD64Rt:
    ::encapfn::rt::EncapfnRt<ABI = ::encapfn::abi::sysv_amd64::SysVAMD64ABI>
    + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
        0usize,
        ::encapfn::abi::calling_convention::AREG2<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
    > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
        0usize,
        ::encapfn::abi::calling_convention::AREG4<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
    > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
        0usize,
        ::encapfn::abi::calling_convention::AREG2<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
    > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
        0usize,
        ::encapfn::abi::calling_convention::AREG1<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
    > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
        0usize,
        ::encapfn::abi::calling_convention::AREG4<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
    > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
        0usize,
        ::encapfn::abi::calling_convention::AREG1<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
    >
{
}
impl<
        RT: ::encapfn::rt::EncapfnRt<ABI = ::encapfn::abi::sysv_amd64::SysVAMD64ABI>
            + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG2<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG4<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG2<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG1<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG4<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            > + ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG1<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            >,
    > LibOTCryptoMACSysVAMD64Rt for RT
{
}
impl<ID: ::encapfn::branding::EFID, RT: LibOTCryptoMACSysVAMD64Rt<ID = ID>>
    LibOTCryptoMAC<ID, RT, ::encapfn::abi::sysv_amd64::SysVAMD64ABI>
    for LibOTCryptoMACRt<'_, ID, RT>
{
    type RT = RT;
    fn rt(&self) -> &Self::RT {
        &self.rt
    }
    #[inline]
    fn otcrypto_hmac_init(
        &self,
        ctx: *mut hmac_context_t,
        key: *const crypto_blinded_key_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<crypto_status_t> {
        #[naked]
        unsafe extern "C" fn otcrypto_hmac_init_int<
            RT: ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG2<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            >,
        >(
            ctx: *mut hmac_context_t,
            key: *const crypto_blinded_key_t,
            _rt: &RT,
            _fnptr: *const (),
            _resptr: &mut RT::InvokeRes<crypto_status_t>,
        ) {
            core :: arch :: asm ! ("lea r10, [rip + {invoke}]" , "jmp r10" , invoke = sym RT :: invoke , options (noreturn) ,);
        }
        let ef_sym = self.rt().lookup_symbol(3usize, &self.symbols).unwrap();
        let mut ef_res = <<RT as ::encapfn::rt::sysv_amd64::SysVAMD64BaseRt>::InvokeRes<
            crypto_status_t,
        > as ::encapfn::rt::sysv_amd64::SysVAMD64InvokeRes<RT, crypto_status_t>>::new(
        );
        let ef_res_borrowed = &mut ef_res;
        self.rt().execute(move || unsafe {
            otcrypto_hmac_init_int::<RT>(ctx, key, self.rt(), ef_sym, ef_res_borrowed);
        });
        ::encapfn::rt::sysv_amd64::SysVAMD64InvokeRes::<RT, crypto_status_t>::into_result_registers(
            ef_res,
            self.rt(),
        )
    }
    #[inline]
    fn otcrypto_hmac_update(
        &self,
        ctx: *mut hmac_context_t,
        input_message: crypto_const_byte_buf_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<crypto_status_t> {
        #[naked]
        unsafe extern "C" fn otcrypto_hmac_update_int<
            RT: ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG4<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            >,
        >(
            ctx: *mut hmac_context_t,
            input_message: crypto_const_byte_buf_t,
            _rt: &RT,
            _fnptr: *const (),
            _resptr: &mut RT::InvokeRes<crypto_status_t>,
        ) {
            core :: arch :: asm ! ("lea r10, [rip + {invoke}]" , "jmp r10" , invoke = sym RT :: invoke , options (noreturn) ,);
        }
        let ef_sym = self.rt().lookup_symbol(2usize, &self.symbols).unwrap();
        let mut ef_res = <<RT as ::encapfn::rt::sysv_amd64::SysVAMD64BaseRt>::InvokeRes<
            crypto_status_t,
        > as ::encapfn::rt::sysv_amd64::SysVAMD64InvokeRes<RT, crypto_status_t>>::new(
        );
        let ef_res_borrowed = &mut ef_res;
        self.rt().execute(move || unsafe {
            otcrypto_hmac_update_int::<RT>(ctx, input_message, self.rt(), ef_sym, ef_res_borrowed);
        });
        ::encapfn::rt::sysv_amd64::SysVAMD64InvokeRes::<RT, crypto_status_t>::into_result_registers(
            ef_res,
            self.rt(),
        )
    }
    #[inline]
    fn otcrypto_hmac_final(
        &self,
        ctx: *mut hmac_context_t,
        tag: *mut crypto_word32_buf_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<crypto_status_t> {
        #[naked]
        unsafe extern "C" fn otcrypto_hmac_final_int<
            RT: ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG2<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            >,
        >(
            ctx: *mut hmac_context_t,
            tag: *mut crypto_word32_buf_t,
            _rt: &RT,
            _fnptr: *const (),
            _resptr: &mut RT::InvokeRes<crypto_status_t>,
        ) {
            core :: arch :: asm ! ("lea r10, [rip + {invoke}]" , "jmp r10" , invoke = sym RT :: invoke , options (noreturn) ,);
        }
        let ef_sym = self.rt().lookup_symbol(4usize, &self.symbols).unwrap();
        let mut ef_res = <<RT as ::encapfn::rt::sysv_amd64::SysVAMD64BaseRt>::InvokeRes<
            crypto_status_t,
        > as ::encapfn::rt::sysv_amd64::SysVAMD64InvokeRes<RT, crypto_status_t>>::new(
        );
        let ef_res_borrowed = &mut ef_res;
        self.rt().execute(move || unsafe {
            otcrypto_hmac_final_int::<RT>(ctx, tag, self.rt(), ef_sym, ef_res_borrowed);
        });
        ::encapfn::rt::sysv_amd64::SysVAMD64InvokeRes::<RT, crypto_status_t>::into_result_registers(
            ef_res,
            self.rt(),
        )
    }
    #[inline]
    fn keyblob_num_words(
        &self,
        config: crypto_key_config_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<usize> {
        #[naked]
        unsafe extern "C" fn keyblob_num_words_int<
            RT: ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG1<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            >,
        >(
            config: *const crypto_key_config_t,
            _rt: &RT,
            _fnptr: *const (),
            _resptr: &mut RT::InvokeRes<usize>,
        ) {
            core :: arch :: asm ! ("lea r10, [rip + {invoke}]" , "jmp r10" , invoke = sym RT :: invoke , options (noreturn) ,);
        }
        self . rt () . allocate_stacked_untracked (:: core :: alloc :: Layout :: new :: < crypto_key_config_t > () , move | config_pbrptr : * mut u8 | { unsafe { :: core :: ptr :: write (config_pbrptr as * mut crypto_key_config_t , config) } ; let config : * const crypto_key_config_t = config_pbrptr as * mut crypto_key_config_t as * const _ ; let ef_sym = self . rt () . lookup_symbol (0usize , & self . symbols) . unwrap () ; let mut ef_res = < < RT as :: encapfn :: rt :: sysv_amd64 :: SysVAMD64BaseRt > :: InvokeRes < usize > as :: encapfn :: rt :: sysv_amd64 :: SysVAMD64InvokeRes < RT , usize > > :: new () ; let ef_res_borrowed = & mut ef_res ; self . rt () . execute (move || { unsafe { keyblob_num_words_int :: < RT > (config , self . rt () , ef_sym , ef_res_borrowed ,) ; } }) ; :: encapfn :: rt :: sysv_amd64 :: SysVAMD64InvokeRes :: < RT , usize > :: into_result_registers (ef_res , self . rt ()) } ,) . unwrap ()
    }
    #[inline]
    fn keyblob_from_key_and_mask(
        &self,
        key: *const u32,
        mask: *const u32,
        config: crypto_key_config_t,
        keyblob: *mut u32,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<status_t> {
        #[naked]
        unsafe extern "C" fn keyblob_from_key_and_mask_int<
            RT: ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG4<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            >,
        >(
            key: *const u32,
            mask: *const u32,
            config: *const crypto_key_config_t,
            keyblob: *mut u32,
            _rt: &RT,
            _fnptr: *const (),
            _resptr: &mut RT::InvokeRes<status_t>,
        ) {
            core :: arch :: asm ! ("lea r10, [rip + {invoke}]" , "jmp r10" , invoke = sym RT :: invoke , options (noreturn) ,);
        }
        self . rt () . allocate_stacked_untracked (:: core :: alloc :: Layout :: new :: < crypto_key_config_t > () , move | config_pbrptr : * mut u8 | { unsafe { :: core :: ptr :: write (config_pbrptr as * mut crypto_key_config_t , config) } ; let config : * const crypto_key_config_t = config_pbrptr as * mut crypto_key_config_t as * const _ ; let ef_sym = self . rt () . lookup_symbol (1usize , & self . symbols) . unwrap () ; let mut ef_res = < < RT as :: encapfn :: rt :: sysv_amd64 :: SysVAMD64BaseRt > :: InvokeRes < status_t > as :: encapfn :: rt :: sysv_amd64 :: SysVAMD64InvokeRes < RT , status_t > > :: new () ; let ef_res_borrowed = & mut ef_res ; self . rt () . execute (move || { unsafe { keyblob_from_key_and_mask_int :: < RT > (key , mask , config , keyblob , self . rt () , ef_sym , ef_res_borrowed ,) ; } }) ; :: encapfn :: rt :: sysv_amd64 :: SysVAMD64InvokeRes :: < RT , status_t > :: into_result_registers (ef_res , self . rt ()) } ,) . unwrap ()
    }
    #[inline]
    fn integrity_blinded_checksum(
        &self,
        key: *const crypto_blinded_key_t,
        _access_scope: &mut ::encapfn::types::AccessScope<ID>,
    ) -> ::encapfn::EFResult<u32> {
        #[naked]
        unsafe extern "C" fn integrity_blinded_checksum_int<
            RT: ::encapfn::rt::sysv_amd64::SysVAMD64Rt<
                0usize,
                ::encapfn::abi::calling_convention::AREG1<::encapfn::abi::sysv_amd64::SysVAMD64ABI>,
            >,
        >(
            key: *const crypto_blinded_key_t,
            _rt: &RT,
            _fnptr: *const (),
            _resptr: &mut RT::InvokeRes<u32>,
        ) {
            core :: arch :: asm ! ("lea r10, [rip + {invoke}]" , "jmp r10" , invoke = sym RT :: invoke , options (noreturn) ,);
        }
        let ef_sym = self.rt().lookup_symbol(5usize, &self.symbols).unwrap();
        let mut ef_res = < < RT as :: encapfn :: rt :: sysv_amd64 :: SysVAMD64BaseRt > :: InvokeRes < u32 > as :: encapfn :: rt :: sysv_amd64 :: SysVAMD64InvokeRes < RT , u32 > > :: new () ;
        let ef_res_borrowed = &mut ef_res;
        self.rt().execute(move || unsafe {
            integrity_blinded_checksum_int::<RT>(key, self.rt(), ef_sym, ef_res_borrowed);
        });
        ::encapfn::rt::sysv_amd64::SysVAMD64InvokeRes::<RT, u32>::into_result_registers(
            ef_res,
            self.rt(),
        )
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const HARDENED_BOOL_TRUE: u32 = 1849;
pub const HARDENED_BOOL_FALSE: u32 = 468;
pub const HARDENED_BYTE_BOOL_TRUE: u32 = 165;
pub const HARDENED_BYTE_BOOL_FALSE: u32 = 75;
pub const _ASSERT_H: u32 = 1;
pub const OT_BUILD_FOR_STATIC_ANALYZER: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const STATUS_BIT_ERROR: u32 = 31;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::core::ffi::c_char,
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_uint,
        __function: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::core::ffi::c_int,
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_uint,
        __function: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::core::ffi::c_char,
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_int,
    ) -> !;
}
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OtSignConversionUnsupportedType {
    pub err: ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_OtSignConversionUnsupportedType() {
    const UNINIT: ::core::mem::MaybeUninit<OtSignConversionUnsupportedType> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OtSignConversionUnsupportedType>(),
        1usize,
        concat!("Size of: ", stringify!(OtSignConversionUnsupportedType))
    );
    assert_eq!(
        ::core::mem::align_of::<OtSignConversionUnsupportedType>(),
        1usize,
        concat!("Alignment of ", stringify!(OtSignConversionUnsupportedType))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OtSignConversionUnsupportedType),
            "::",
            stringify!(err)
        )
    );
}
#[doc = " The truthy value, expected to be used like #true."]
pub const hardened_bool_kHardenedBoolTrue: hardened_bool = 1849;
#[doc = " The falsey value, expected to be used like #false."]
pub const hardened_bool_kHardenedBoolFalse: hardened_bool = 468;
#[doc = " This is a boolean type for use in hardened contexts.\n\n The intention is that this is used instead of `<stdbool.h>`'s #bool, where a\n higher hamming distance is required between the truthy and the falsey value.\n\n The values below were chosen at random, with some specific restrictions. They\n have a Hamming Distance of 8, and they are 11-bit values so they can be\n materialized with a single instruction on RISC-V. They are also specifically\n not the complement of each other."]
pub type hardened_bool = ::core::ffi::c_uint;
#[doc = " This is a boolean type for use in hardened contexts.\n\n The intention is that this is used instead of `<stdbool.h>`'s #bool, where a\n higher hamming distance is required between the truthy and the falsey value.\n\n The values below were chosen at random, with some specific restrictions. They\n have a Hamming Distance of 8, and they are 11-bit values so they can be\n materialized with a single instruction on RISC-V. They are also specifically\n not the complement of each other."]
pub use self::hardened_bool as hardened_bool_t;
#[doc = " The truthy value."]
pub const hardened_byte_bool_kHardenedByteBoolTrue: hardened_byte_bool = 165;
#[doc = " The falsy value."]
pub const hardened_byte_bool_kHardenedByteBoolFalse: hardened_byte_bool = 75;
#[doc = " A byte-sized hardened boolean.\n\n This type is intended for cases where a byte-sized hardened boolean is\n required, e.g. for the entries of the `CREATOR_SW_CFG_SIGVERIFY_RSA_KEY_EN`\n OTP item.\n\n The values below were chosen to ensure that the hamming difference between\n them is greater than 5 and they are not bitwise complements of each other."]
pub type hardened_byte_bool = ::core::ffi::c_uint;
#[doc = " A byte-sized hardened boolean.\n\n This type is intended for cases where a byte-sized hardened boolean is\n required, e.g. for the entries of the `CREATOR_SW_CFG_SIGVERIFY_RSA_KEY_EN`\n OTP item.\n\n The values below were chosen to ensure that the hamming difference between\n them is greater than 5 and they are not bitwise complements of each other."]
pub use self::hardened_byte_bool as hardened_byte_bool_t;
#[doc = " A constant-time, 32-bit boolean value.\n\n Values of this type MUST be either all zero bits or all one bits,\n representing `false` and `true` respectively.\n\n Although it is possible to convert an existing `bool` into a `ct_bool32_t` by\n writing `-((ct_bool32_t) my_bool)`, we recommend against it"]
pub type ct_bool32_t = u32;
#[doc = " A constant-time, pointer-sized boolean value.\n\n Values of this type MUST be either all zero bits or all one bits."]
pub type ct_boolw_t = usize;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::core::mem::MaybeUninit<__locale_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::core::ffi::c_void, __dest: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
#[doc = " A field of a 32-bit bitfield.\n\n The following field definition: `{ .mask = 0b11, .index = 12 }`\n\n Denotes the X-marked bits in the following 32-bit bitfield:\n\n     field:  0b--------'--------'--XX----'--------\n     index:   31                                 0\n\n Restrictions: The index plus the width of the mask must not be greater than\n 31."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitfield_field32 {
    #[doc = " The field mask. Usually all ones."]
    pub mask: u32,
    #[doc = " The field position in the bitfield, counting from the zero-bit."]
    pub index: u32,
}
#[test]
fn bindgen_test_layout_bitfield_field32() {
    const UNINIT: ::core::mem::MaybeUninit<bitfield_field32> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bitfield_field32>(),
        8usize,
        concat!("Size of: ", stringify!(bitfield_field32))
    );
    assert_eq!(
        ::core::mem::align_of::<bitfield_field32>(),
        4usize,
        concat!("Alignment of ", stringify!(bitfield_field32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bitfield_field32),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bitfield_field32),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " A field of a 32-bit bitfield.\n\n The following field definition: `{ .mask = 0b11, .index = 12 }`\n\n Denotes the X-marked bits in the following 32-bit bitfield:\n\n     field:  0b--------'--------'--XX----'--------\n     index:   31                                 0\n\n Restrictions: The index plus the width of the mask must not be greater than\n 31."]
pub type bitfield_field32_t = bitfield_field32;
#[doc = " A single bit in a 32-bit bitfield.\n\n This denotes the position of a single bit, counting from the zero-bit.\n\n For instance, `(bitfield_bit_index_t)4` denotes the X-marked bit in the\n following 32-bit bitfield:\n\n     field:  0b--------'--------'--------'---X----\n     index:   31                                 0\n\n Restrictions: The value must not be greater than 31."]
pub type bitfield_bit32_index_t = u32;
#[doc = " 4-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool4True: multi_bit_bool = 6;
#[doc = " 4-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool4False: multi_bit_bool = 9;
#[doc = " 8-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool8True: multi_bit_bool = 150;
#[doc = " 8-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool8False: multi_bit_bool = 105;
#[doc = " 12-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool12True: multi_bit_bool = 1686;
#[doc = " 12-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool12False: multi_bit_bool = 2409;
#[doc = " 16-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool16True: multi_bit_bool = 38550;
#[doc = " 16-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool16False: multi_bit_bool = 26985;
#[doc = " Multi-bit boolean values\n\n Certain configuration fields in the design are multi-bits.\n This gives the configuration fields redundancy and ensures\n it is difficult to fault the values to a \"good\" state."]
pub type multi_bit_bool = ::core::ffi::c_uint;
#[doc = " Multi-bit boolean values\n\n Certain configuration fields in the design are multi-bits.\n This gives the configuration fields redundancy and ensures\n it is difficult to fault the values to a \"good\" state."]
pub use self::multi_bit_bool as multi_bit_bool_t;
pub const absl_status_code_kOk: absl_status_code = 0;
pub const absl_status_code_kCancelled: absl_status_code = 1;
pub const absl_status_code_kUnknown: absl_status_code = 2;
pub const absl_status_code_kInvalidArgument: absl_status_code = 3;
pub const absl_status_code_kDeadlineExceeded: absl_status_code = 4;
pub const absl_status_code_kNotFound: absl_status_code = 5;
pub const absl_status_code_kAlreadyExists: absl_status_code = 6;
pub const absl_status_code_kPermissionDenied: absl_status_code = 7;
pub const absl_status_code_kResourceExhausted: absl_status_code = 8;
pub const absl_status_code_kFailedPrecondition: absl_status_code = 9;
pub const absl_status_code_kAborted: absl_status_code = 10;
pub const absl_status_code_kOutOfRange: absl_status_code = 11;
pub const absl_status_code_kUnimplemented: absl_status_code = 12;
pub const absl_status_code_kInternal: absl_status_code = 13;
pub const absl_status_code_kUnavailable: absl_status_code = 14;
pub const absl_status_code_kDataLoss: absl_status_code = 15;
pub const absl_status_code_kUnauthenticated: absl_status_code = 16;
pub const absl_status_code_kDoNotUseReservedForFutureExpansionUseDefaultInSwitchInstead_:
    absl_status_code = 20;
#[doc = " This enum was taken directly from the abseil-cpp library:\n https://github.com/abseil/abseil-cpp/blob/master/absl/status/status.h\n\n These error codes serve as general error classifications which are used to\n build up more specific error codes.\n\n DO NOT USE THESE CODES DIRECTLY. Use these codes to build per-module error\n codes in error.h.  Although these error codes are generally used at\n Google by RPC servers, the advice about how to use them and how to\n categorize errors is generally sound."]
pub type absl_status_code = ::core::ffi::c_uint;
#[doc = " This enum was taken directly from the abseil-cpp library:\n https://github.com/abseil/abseil-cpp/blob/master/absl/status/status.h\n\n These error codes serve as general error classifications which are used to\n build up more specific error codes.\n\n DO NOT USE THESE CODES DIRECTLY. Use these codes to build per-module error\n codes in error.h.  Although these error codes are generally used at\n Google by RPC servers, the advice about how to use them and how to\n categorize errors is generally sound."]
pub use self::absl_status_code as absl_status_t;
#[doc = " Indicates that the operation succeeded."]
pub const dif_result_kDifOk: dif_result = 0;
#[doc = " Indicates some unspecified failure."]
pub const dif_result_kDifError: dif_result = 13;
#[doc = " Indicates that some parameter passed into a function failed a\n precondition.\n\n When this value is returned, no hardware operations occurred."]
pub const dif_result_kDifBadArg: dif_result = 3;
#[doc = " The operation failed because writes to a required register are\n disabled."]
pub const dif_result_kDifLocked: dif_result = 9;
#[doc = " The operation failed because the IP is processing an operation, and will\n finish in some amount of time. A function that returns this error may be\n retried at any time, and is guaranteed to have not produced any side\n effects."]
pub const dif_result_kDifUnavailable: dif_result = 14;
#[doc = " Indicates that the Ip's FIFO (if it has one or more of) is full."]
pub const dif_result_kDifIpFifoFull: dif_result = 8;
#[doc = " Indicates that the attempted operation would attempt a read/write to an\n address that would go out of range."]
pub const dif_result_kDifOutOfRange: dif_result = 11;
#[doc = " Indicates that the attempted operation would attempt a read/write to an\n address that is not aligned."]
pub const dif_result_kDifUnaligned: dif_result = 12;
#[doc = " The result of a DIF operation.\n\n NOTE: additional result values can be defined in the manually-implemented\n header by creating an additional *_result_t enum type. See the Lifecycle\n Controller DIF for how this may be implemented."]
pub type dif_result = ::core::ffi::c_uint;
#[doc = " The result of a DIF operation.\n\n NOTE: additional result values can be defined in the manually-implemented\n header by creating an additional *_result_t enum type. See the Lifecycle\n Controller DIF for how this may be implemented."]
pub use self::dif_result as dif_result_t;
#[doc = " The \"disabled\" state."]
pub const dif_toggle_kDifToggleDisabled: dif_toggle = 0;
#[doc = " The \"enabled\" state."]
pub const dif_toggle_kDifToggleEnabled: dif_toggle = 1;
#[doc = " A toggle state: enabled, or disabled.\n\n This enum may be used instead of a `bool` when describing an enabled/disabled\n state."]
pub type dif_toggle = ::core::ffi::c_uint;
#[doc = " A toggle state: enabled, or disabled.\n\n This enum may be used instead of a `bool` when describing an enabled/disabled\n state."]
pub use self::dif_toggle as dif_toggle_t;
#[doc = " Event type interrupt."]
pub const dif_irq_type_kDifIrqTypeEvent: dif_irq_type = 0;
#[doc = " Status type interrupt."]
pub const dif_irq_type_kDifIrqTypeStatus: dif_irq_type = 1;
#[doc = " An interrupt type: event, or status.\n\n This enum may be used instead when describing an interrupt type.\n Specifically, event interrupts require software to manually clear them by\n writing to the interrupt status register (after handling the root cause),\n while status interrupts clear immediately when the root cause of the iterrupt\n has been handled."]
pub type dif_irq_type = ::core::ffi::c_uint;
#[doc = " An interrupt type: event, or status.\n\n This enum may be used instead when describing an interrupt type.\n Specifically, event interrupts require software to manually clear them by\n writing to the interrupt status register (after handling the root cause),\n while status interrupts clear immediately when the root cause of the iterrupt\n has been handled."]
pub use self::dif_irq_type as dif_irq_type_t;
pub const module__kModuleUnknown: module_ = 0;
pub const module__kModuleAlertHandler: module_ = 16712;
pub const module__kModuleSigverify: module_ = 21334;
pub const module__kModuleKeymgr: module_ = 19277;
pub const module__kModuleManifest: module_ = 19777;
pub const module__kModuleRom: module_ = 19794;
pub const module__kModuleInterrupt: module_ = 18770;
pub const module__kModuleEpmp: module_ = 17744;
pub const module__kModuleKmac: module_ = 19267;
pub const module__kModuleOtbn: module_ = 16974;
pub const module__kModuleFlashCtrl: module_ = 17987;
pub const module__kModuleBootPolicy: module_ = 16976;
pub const module__kModuleBootstrap: module_ = 16979;
pub const module__kModuleLog: module_ = 19527;
pub const module__kModuleBootData: module_ = 16964;
pub const module__kModuleSpiDevice: module_ = 21328;
pub const module__kModuleAst: module_ = 16723;
pub const module__kModuleRstmgr: module_ = 21075;
pub const module__KModuleRnd: module_ = 21070;
pub const module__kModuleBootSvc: module_ = 16963;
pub const module__kModuleBootLog: module_ = 16972;
pub const module__kModuleRomExt: module_ = 21061;
pub const module__kModuleRomExtInterrupt: module_ = 21065;
pub const module__kModuleAsn1: module_ = 16689;
pub type module_ = ::core::ffi::c_uint;
pub const rom_error_kErrorOk: rom_error = 1849;
pub const rom_error_kErrorUnknown: rom_error = 4294967295;
pub const rom_error_kErrorSigverifyBadRsaSignature: rom_error = 22238723;
pub const rom_error_kErrorSigverifyBadSpxSignature: rom_error = 39015939;
pub const rom_error_kErrorSigverifyBadKey: rom_error = 55793155;
pub const rom_error_kErrorSigverifyBadRsaKey: rom_error = 72570371;
pub const rom_error_kErrorSigverifyBadSpxKey: rom_error = 89347587;
pub const rom_error_kErrorSigverifyLargeRsaSignature: rom_error = 106124803;
pub const rom_error_kErrorKeymgrInternal: rom_error = 21712141;
pub const rom_error_kErrorManifestBadEntryPoint: rom_error = 21840141;
pub const rom_error_kErrorManifestBadCodeRegion: rom_error = 38617357;
pub const rom_error_kErrorManifestBadSignedRegion: rom_error = 55394573;
pub const rom_error_kErrorManifestBadExtension: rom_error = 72171789;
pub const rom_error_kErrorManifestBadVersionMajor: rom_error = 88949005;
pub const rom_error_kErrorAlertBadIndex: rom_error = 21055491;
pub const rom_error_kErrorAlertBadClass: rom_error = 37832707;
pub const rom_error_kErrorAlertBadEnable: rom_error = 54609923;
pub const rom_error_kErrorAlertBadEscalation: rom_error = 71387139;
pub const rom_error_kErrorAlertBadCrc32: rom_error = 88164355;
pub const rom_error_kErrorRomBootFailed: rom_error = 21844489;
pub const rom_error_kErrorInterrupt: rom_error = 4805122;
pub const rom_error_kErrorEpmpBadCheck: rom_error = 21319693;
pub const rom_error_kErrorKmacInvalidStatus: rom_error = 21709581;
pub const rom_error_kErrorOtbnInvalidArgument: rom_error = 21122563;
pub const rom_error_kErrorOtbnBadOffsetLen: rom_error = 37899779;
pub const rom_error_kErrorOtbnExecutionFailed: rom_error = 54677005;
pub const rom_error_kErrorOtbnSecWipeImemFailed: rom_error = 71454221;
pub const rom_error_kErrorOtbnSecWipeDmemFailed: rom_error = 88231437;
pub const rom_error_kErrorOtbnBadInsnCount: rom_error = 105008653;
pub const rom_error_kErrorOtbnUnavailable: rom_error = 121785869;
pub const rom_error_kErrorFlashCtrlDataRead: rom_error = 21381901;
pub const rom_error_kErrorFlashCtrlInfoRead: rom_error = 38159117;
pub const rom_error_kErrorFlashCtrlDataWrite: rom_error = 54936333;
pub const rom_error_kErrorFlashCtrlInfoWrite: rom_error = 71713549;
pub const rom_error_kErrorFlashCtrlDataErase: rom_error = 88490765;
pub const rom_error_kErrorFlashCtrlInfoErase: rom_error = 105267981;
pub const rom_error_kErrorFlashCtrlDataEraseVerify: rom_error = 122045197;
pub const rom_error_kErrorBootPolicyBadIdentifier: rom_error = 21123085;
pub const rom_error_kErrorBootPolicyBadLength: rom_error = 37900301;
pub const rom_error_kErrorBootPolicyRollback: rom_error = 54677517;
pub const rom_error_kErrorBootstrapEraseAddress: rom_error = 21123843;
pub const rom_error_kErrorBootstrapProgramAddress: rom_error = 37901059;
pub const rom_error_kErrorBootstrapInvalidState: rom_error = 54678275;
pub const rom_error_kErrorBootstrapNotRequested: rom_error = 71455501;
pub const rom_error_kErrorBootstrapDisabledRomExt: rom_error = 88232717;
pub const rom_error_kErrorLogBadFormatSpecifier: rom_error = 21776141;
pub const rom_error_kErrorBootDataNotFound: rom_error = 21120013;
pub const rom_error_kErrorBootDataWriteCheck: rom_error = 37897229;
pub const rom_error_kErrorBootDataInvalid: rom_error = 54674445;
pub const rom_error_kErrorSpiDevicePayloadOverflow: rom_error = 22237197;
pub const rom_error_kErrorAstInitNotDone: rom_error = 21058317;
pub const rom_error_kErrorRstmgrBadInit: rom_error = 22172429;
pub const rom_error_kErrorRndBadCrc32: rom_error = 22171139;
pub const rom_error_kErrorBootSvcBadHeader: rom_error = 21119757;
pub const rom_error_kErrorBootSvcBadSlot: rom_error = 37896963;
pub const rom_error_kErrorRomExtBootFailed: rom_error = 22168841;
pub const rom_error_kErrorRomExtInterrupt: rom_error = 5392642;
pub const rom_error_kErrorBootLogInvalid: rom_error = 21122061;
pub const rom_error_kErrorAsn1Internal: rom_error = 21049613;
pub const rom_error_kErrorAsn1InvalidArgument: rom_error = 37826819;
pub const rom_error_kErrorAsn1BufferExhausted: rom_error = 54604040;
#[doc = " Unified set of errors for ROM and ROM_EXT."]
pub type rom_error = ::core::ffi::c_uint;
#[doc = " Unified set of errors for ROM and ROM_EXT."]
pub use self::rom_error as rom_error_t;
#[doc = " We use the error category codes from absl_status.h.  We build a packed\n status value that identifies the source of the error (in the form of the\n module identifier and line number).\n\n By default, the module identifier is the first three letters of the\n source filename.  The identifier can be overridden (per-module) with the\n DECLARE_MODULE_ID macro.\n\n Our status codes are arranged as a packed bitfield, with the sign\n bit signifying whether the value represents a result or an error.\n\n All Ok (good) values:\n 32  31                                             0\n  +---+---------------------------------------------+\n  |   |                  31 bit                     |\n  | 0 |                  Result                     |\n  +---+---------------------------------------------+\n\n All Error values:\n 32  31      26      21      16             5       0\n  +---+-------+-------+-------+-------------+-------+\n  |   |   15 bit              | 11 bit      | 5 bit |\n  | 1 |   Module Identifier   | Line Number | code  |\n  +---+-------+-------+-------+-------------+-------+\n\n The module identifier value is interpreted as three 5-bit fields\n representing the characters [0x40..0x5F] (e.g. [@ABC ... _])."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status {
    pub value: i32,
}
#[test]
fn bindgen_test_layout_status() {
    const UNINIT: ::core::mem::MaybeUninit<status> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<status>(),
        4usize,
        concat!("Size of: ", stringify!(status))
    );
    assert_eq!(
        ::core::mem::align_of::<status>(),
        4usize,
        concat!("Alignment of ", stringify!(status))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(status),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " We use the error category codes from absl_status.h.  We build a packed\n status value that identifies the source of the error (in the form of the\n module identifier and line number).\n\n By default, the module identifier is the first three letters of the\n source filename.  The identifier can be overridden (per-module) with the\n DECLARE_MODULE_ID macro.\n\n Our status codes are arranged as a packed bitfield, with the sign\n bit signifying whether the value represents a result or an error.\n\n All Ok (good) values:\n 32  31                                             0\n  +---+---------------------------------------------+\n  |   |                  31 bit                     |\n  | 0 |                  Result                     |\n  +---+---------------------------------------------+\n\n All Error values:\n 32  31      26      21      16             5       0\n  +---+-------+-------+-------+-------------+-------+\n  |   |   15 bit              | 11 bit      | 5 bit |\n  | 1 |   Module Identifier   | Line Number | code  |\n  +---+-------+-------+-------+-------------+-------+\n\n The module identifier value is interpreted as three 5-bit fields\n representing the characters [0x40..0x5F] (e.g. [@ABC ... _])."]
pub type status_t = status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ot_status_create_record {
    pub module_id: u32,
    pub filename: [::core::ffi::c_char; 124usize],
}
#[test]
fn bindgen_test_layout_ot_status_create_record() {
    const UNINIT: ::core::mem::MaybeUninit<ot_status_create_record> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ot_status_create_record>(),
        128usize,
        concat!("Size of: ", stringify!(ot_status_create_record))
    );
    assert_eq!(
        ::core::mem::align_of::<ot_status_create_record>(),
        4usize,
        concat!("Alignment of ", stringify!(ot_status_create_record))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ot_status_create_record),
            "::",
            stringify!(module_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ot_status_create_record),
            "::",
            stringify!(filename)
        )
    );
}
pub type ot_status_create_record_t = ot_status_create_record;
pub const ot_status_create_record_magic_OT_SCR_UNKNOWN_MOD_ID: ot_status_create_record_magic =
    4294967295;
pub type ot_status_create_record_magic = ::core::ffi::c_uint;
extern "C" {
    #[doc = " Report an error status.\n\n This header does not specify how the error is\n reported, or if it reported at all. Since status_t encodes the location\n of an error, this provides the infrastructure for a lightweight\n \"stack trace\"."]
    pub fn status_report(value: status_t);
}
extern "C" {
    pub static MODULE_ID: u32;
}
extern "C" {
    #[doc = " Creates a packed status_t.\n\n @param code An absl_status code.\n @param mod_id The module creating the status code.\n @param file The filename of the module creating the code.\n @param arg The argument associated with the status.\n @return `status_t`."]
    pub fn status_create(
        code: absl_status_t,
        mod_id: u32,
        file: *const ::core::ffi::c_char,
        arg: i32,
    ) -> status_t;
}
extern "C" {
    #[doc = " Extracts the packed values from a status code.\n\n @param s The status code to extract values from.\n @param code Pointer to the english name of the status code.\n @param arg Pointer to an integer argument.\n @param mod_id Pointer to a char[3] buffer for the module id.\n @return True if the status represents and error, False if the status\n represents Ok."]
    pub fn status_extract(
        s: status_t,
        code: *mut *const ::core::ffi::c_char,
        arg: *mut i32,
        mod_id: *mut ::core::ffi::c_char,
    ) -> bool;
}
#[doc = " Return values for the crypto library.\n\n The crypto library's return value is defined as OpenTitan's internal\n `status_t` in order to simplify testing. However, informally the library\n guarantees that the concrete value contained in the status will be one of\n the members of the `crypto_status_value` enum below."]
pub type crypto_status_t = status_t;
pub const crypto_status_value_kCryptoStatusOK: crypto_status_value = 1849;
pub const crypto_status_value_kCryptoStatusBadArgs: crypto_status_value = -2147418461;
pub const crypto_status_value_kCryptoStatusInternalError: crypto_status_value = -2147462326;
pub const crypto_status_value_kCryptoStatusFatalError: crypto_status_value = -2147455607;
pub const crypto_status_value_kCryptoStatusAsyncIncomplete: crypto_status_value = -2147423666;
pub const crypto_status_value_kCryptoStatusNotImplemented: crypto_status_value = -2147447508;
#[doc = " Possible status values for the cryptolib.\n\n As long as the OTCRYPTO_STATUS_DEBUG define is unset, all `crypto_status_t`\n codes returned by the cryptolib should be bit-by-bit equivalent with one of\n the values in this enum.\n\n Values are built to be bit-compatible with OpenTitan's internal `status_t`\n datatypes. The highest (sign) bit indicates if the value is an error (1) or\n not (0). For non-error statuses, the rest can be anything; in cryptolib\n status codes it is always `kHardenedBoolTrue`. For errors:\n   - The next 15 bits are a module identifier, which is always 0 in the\n     cryptolib status codes\n   - The next 11 bits are a line number or other information; in the\n     cryptolib status codes, it is a hardened value created to have high\n     Hamming distance with the other valid status codes\n   - The final 5 bits are an Abseil-compatible error code\n\n The hardened values for error codes were generated with:\n $ ./util/design/sparse-fsm-encode.py -d 5 -m 5 -n 11 \\\n      -s 4232058530 --language=sv --avoid-zero\n\n Use the same seed value and a larger `-m` argument to generate new values\n without changing all error codes. Remove the seed (-s argument) to generate\n completely new 11-bit values."]
pub type crypto_status_value = ::core::ffi::c_int;
#[doc = " Possible status values for the cryptolib.\n\n As long as the OTCRYPTO_STATUS_DEBUG define is unset, all `crypto_status_t`\n codes returned by the cryptolib should be bit-by-bit equivalent with one of\n the values in this enum.\n\n Values are built to be bit-compatible with OpenTitan's internal `status_t`\n datatypes. The highest (sign) bit indicates if the value is an error (1) or\n not (0). For non-error statuses, the rest can be anything; in cryptolib\n status codes it is always `kHardenedBoolTrue`. For errors:\n   - The next 15 bits are a module identifier, which is always 0 in the\n     cryptolib status codes\n   - The next 11 bits are a line number or other information; in the\n     cryptolib status codes, it is a hardened value created to have high\n     Hamming distance with the other valid status codes\n   - The final 5 bits are an Abseil-compatible error code\n\n The hardened values for error codes were generated with:\n $ ./util/design/sparse-fsm-encode.py -d 5 -m 5 -n 11 \\\n      -s 4232058530 --language=sv --avoid-zero\n\n Use the same seed value and a larger `-m` argument to generate new values\n without changing all error codes. Remove the seed (-s argument) to generate\n completely new 11-bit values."]
pub use self::crypto_status_value as crypto_status_value_t;
#[doc = " Struct to hold a fixed-length byte array.\n\n Note: the caller must (1) allocate sufficient space and (2) set the `len`\n field and `data` pointer when `crypto_byte_buf_t` is used for output. The\n crypto library will throw an error if `len` doesn't match expectations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_byte_buf {
    pub len: usize,
    pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_crypto_byte_buf() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_byte_buf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_byte_buf>(),
        16usize,
        concat!("Size of: ", stringify!(crypto_byte_buf))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_byte_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_byte_buf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_byte_buf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_byte_buf),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Struct to hold a fixed-length byte array.\n\n Note: the caller must (1) allocate sufficient space and (2) set the `len`\n field and `data` pointer when `crypto_byte_buf_t` is used for output. The\n crypto library will throw an error if `len` doesn't match expectations."]
pub type crypto_byte_buf_t = crypto_byte_buf;
#[doc = " Struct to hold a constant fixed-length byte array.\n\n The const annotations prevent any changes to the byte buffer. It is\n necessary to have this structure separate from `crypto_byte_buf_t` because\n data pointed to by a struct does not inherit `const`, so `const\n crypto_byte_buf_t` would still allow data to change."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_const_byte_buf {
    pub len: usize,
    pub data: *const u8,
}
#[test]
fn bindgen_test_layout_crypto_const_byte_buf() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_const_byte_buf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_const_byte_buf>(),
        16usize,
        concat!("Size of: ", stringify!(crypto_const_byte_buf))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_const_byte_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_const_byte_buf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_const_byte_buf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_const_byte_buf),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Struct to hold a constant fixed-length byte array.\n\n The const annotations prevent any changes to the byte buffer. It is\n necessary to have this structure separate from `crypto_byte_buf_t` because\n data pointed to by a struct does not inherit `const`, so `const\n crypto_byte_buf_t` would still allow data to change."]
pub type crypto_const_byte_buf_t = crypto_const_byte_buf;
#[doc = " Struct to hold a fixed-length word array.\n\n Note: the caller must (1) allocate sufficient space and (2) set the `len`\n field and `data` pointer when `crypto_word32_buf_t` is used for output. The\n crypto library will throw an error if `len` doesn't match expectations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_word32_buf {
    pub len: usize,
    pub data: *mut u32,
}
#[test]
fn bindgen_test_layout_crypto_word32_buf() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_word32_buf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_word32_buf>(),
        16usize,
        concat!("Size of: ", stringify!(crypto_word32_buf))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_word32_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_word32_buf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_word32_buf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_word32_buf),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Struct to hold a fixed-length word array.\n\n Note: the caller must (1) allocate sufficient space and (2) set the `len`\n field and `data` pointer when `crypto_word32_buf_t` is used for output. The\n crypto library will throw an error if `len` doesn't match expectations."]
pub type crypto_word32_buf_t = crypto_word32_buf;
#[doc = " Struct to hold a constant fixed-length word array.\n\n The const annotations prevent any changes to the word buffer. It is\n necessary to have this structure separate from `crypto_word32_buf_t` because\n data pointed to by a struct does not inherit `const`, so `const\n crypto_word32_buf_t` would still allow data to change."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_const_word32_buf {
    pub len: usize,
    pub data: *const u32,
}
#[test]
fn bindgen_test_layout_crypto_const_word32_buf() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_const_word32_buf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_const_word32_buf>(),
        16usize,
        concat!("Size of: ", stringify!(crypto_const_word32_buf))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_const_word32_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_const_word32_buf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_const_word32_buf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_const_word32_buf),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Struct to hold a constant fixed-length word array.\n\n The const annotations prevent any changes to the word buffer. It is\n necessary to have this structure separate from `crypto_word32_buf_t` because\n data pointed to by a struct does not inherit `const`, so `const\n crypto_word32_buf_t` would still allow data to change."]
pub type crypto_const_word32_buf_t = crypto_const_word32_buf;
pub const key_type_kKeyTypeAes: key_type = 2281;
pub const key_type_kKeyTypeHmac: key_type = 3647;
pub const key_type_kKeyTypeKmac: key_type = 2932;
pub const key_type_kKeyTypeRsa: key_type = 2030;
pub const key_type_kKeyTypeEcc: key_type = 347;
pub const key_type_kKeyTypeKdf: key_type = 2951;
#[doc = " Enum to denote the key type of the handled key.\n\n Values are hardened."]
pub type key_type = ::core::ffi::c_uint;
#[doc = " Enum to denote the key type of the handled key.\n\n Values are hardened."]
pub use self::key_type as key_type_t;
pub const aes_key_mode_kAesKeyModeEcb: aes_key_mode = 438;
pub const aes_key_mode_kAesKeyModeCbc: aes_key_mode = 3898;
pub const aes_key_mode_kAesKeyModeCfb: aes_key_mode = 249;
pub const aes_key_mode_kAesKeyModeOfb: aes_key_mode = 2889;
pub const aes_key_mode_kAesKeyModeCtr: aes_key_mode = 1230;
pub const aes_key_mode_kAesKeyModeGcm: aes_key_mode = 2725;
pub const aes_key_mode_kAesKeyModeKwp: aes_key_mode = 2005;
#[doc = " Enum to specify the AES modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type aes_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the AES modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::aes_key_mode as aes_key_mode_t;
pub const hmac_key_mode_kHmacKeyModeSha256: hmac_key_mode = 2045;
pub const hmac_key_mode_kHmacKeyModeSha384: hmac_key_mode = 1083;
pub const hmac_key_mode_kHmacKeyModeSha512: hmac_key_mode = 1954;
#[doc = " Enum to specify the HMAC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type hmac_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the HMAC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::hmac_key_mode as hmac_key_mode_t;
pub const kmac_key_mode_kKmacKeyModeKmac128: kmac_key_mode = 2646;
pub const kmac_key_mode_kKmacKeyModeKmac256: kmac_key_mode = 1635;
#[doc = " Enum to specify the KMAC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type kmac_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the KMAC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::kmac_key_mode as kmac_key_mode_t;
pub const rsa_key_mode_kRsaKeyModeSignPkcs: rsa_key_mode = 980;
pub const rsa_key_mode_kRsaKeyModeSignPss: rsa_key_mode = 1889;
pub const rsa_key_mode_kRsaKeyModeEncryptOaep: rsa_key_mode = 1413;
#[doc = " Enum to specify the RSA modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type rsa_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the RSA modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::rsa_key_mode as rsa_key_mode_t;
pub const ecc_key_mode_kEccKeyModeEcdsa: ecc_key_mode = 1253;
pub const ecc_key_mode_kEccKeyModeEcdh: ecc_key_mode = 1723;
pub const ecc_key_mode_kEccKeyModeEd25519: ecc_key_mode = 3378;
pub const ecc_key_mode_kEccKeyModeX25519: ecc_key_mode = 630;
#[doc = " Enum to specify the ECC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type ecc_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the ECC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::ecc_key_mode as ecc_key_mode_t;
pub const kdf_key_mode_kKdfKeyModeCtrHMAC: kdf_key_mode = 295;
pub const kdf_key_mode_kKdfKeyModeCtrKMAC: kdf_key_mode = 989;
#[doc = " Enum to specify the KDF modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type kdf_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the KDF modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::kdf_key_mode as kdf_key_mode_t;
pub const key_mode_kKeyModeAesEcb: key_mode = 149488054;
pub const key_mode_kKeyModeAesCbc: key_mode = 149491514;
pub const key_mode_kKeyModeAesCfb: key_mode = 149487865;
pub const key_mode_kKeyModeAesOfb: key_mode = 149490505;
pub const key_mode_kKeyModeAesCtr: key_mode = 149488846;
pub const key_mode_kKeyModeAesGcm: key_mode = 149490341;
pub const key_mode_kKeyModeAesKwp: key_mode = 149489621;
pub const key_mode_kKeyModeHmacSha256: key_mode = 239011837;
pub const key_mode_kKeyModeHmacSha384: key_mode = 239010875;
pub const key_mode_kKeyModeHmacSha512: key_mode = 239011746;
pub const key_mode_kKeyModeKmac128: key_mode = 192154198;
pub const key_mode_kKeyModeKmac256: key_mode = 192153187;
pub const key_mode_kKeyModeRsaSignPkcs: key_mode = 133039060;
pub const key_mode_kKeyModeRsaSignPss: key_mode = 133039969;
pub const key_mode_kKeyModeRsaEncryptOaep: key_mode = 133039493;
pub const key_mode_kKeyModeEcdsa: key_mode = 22742245;
pub const key_mode_kKeyModeEcdh: key_mode = 22742715;
pub const key_mode_kKeyModeEd25519: key_mode = 22744370;
pub const key_mode_kKeyModeX25519: key_mode = 22741622;
pub const key_mode_kKeyModeKdfCtrHmac: key_mode = 193397031;
pub const key_mode_kKeyModeKdfCtrKmac: key_mode = 193397725;
#[doc = " Enum for opentitan crypto modes that use a key.\n\n Denotes the crypto mode for which the provided key is to be used.\n This `key_mode_t` will be a parameter in the `crypto_blinded_key_t`\n and `crypto_unblinded_key_t` structs.\n\n Values are hardened."]
pub type key_mode = ::core::ffi::c_uint;
#[doc = " Enum for opentitan crypto modes that use a key.\n\n Denotes the crypto mode for which the provided key is to be used.\n This `key_mode_t` will be a parameter in the `crypto_blinded_key_t`\n and `crypto_unblinded_key_t` structs.\n\n Values are hardened."]
pub use self::key_mode as key_mode_t;
pub const crypto_key_security_level_kSecurityLevelLow: crypto_key_security_level = 489;
pub const crypto_key_security_level_kSecurityLevelMedium: crypto_key_security_level = 3755;
pub const crypto_key_security_level_kSecurityLevelHigh: crypto_key_security_level = 2686;
#[doc = " Enum to denote key security level.\n\n At high security levels, the crypto library will prioritize\n protecting the key from sophisticated attacks, even at large\n performance costs. If the security level is low, the crypto\n library will still try to protect the key, but may forgo the\n most costly protections against e.g. sophisticated physical\n attacks.\n\n Values are hardened."]
pub type crypto_key_security_level = ::core::ffi::c_uint;
#[doc = " Enum to denote key security level.\n\n At high security levels, the crypto library will prioritize\n protecting the key from sophisticated attacks, even at large\n performance costs. If the security level is low, the crypto\n library will still try to protect the key, but may forgo the\n most costly protections against e.g. sophisticated physical\n attacks.\n\n Values are hardened."]
pub use self::crypto_key_security_level as crypto_key_security_level_t;
pub const crypto_lib_version_kCryptoLibVersion1: crypto_lib_version = 2036;
#[doc = " Enum to denote the crypto library version.\n\n In future updates, this enum will be extended to preserve some\n level of backwards-compatibility despite changes to internal\n details (for example, the preferred masking scheme for blinded\n keys).\n\n Values are hardened."]
pub type crypto_lib_version = ::core::ffi::c_uint;
#[doc = " Enum to denote the crypto library version.\n\n In future updates, this enum will be extended to preserve some\n level of backwards-compatibility despite changes to internal\n details (for example, the preferred masking scheme for blinded\n keys).\n\n Values are hardened."]
pub use self::crypto_lib_version as crypto_lib_version_t;
#[doc = " Struct to represent the configuration of a blinded key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_key_config {
    pub version: crypto_lib_version_t,
    pub key_mode: key_mode_t,
    pub key_length: usize,
    pub hw_backed: hardened_bool_t,
    pub exportable: hardened_bool_t,
    pub security_level: crypto_key_security_level_t,
}
#[test]
fn bindgen_test_layout_crypto_key_config() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_key_config> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_key_config>(),
        32usize,
        concat!("Size of: ", stringify!(crypto_key_config))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_key_config>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_key_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(key_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(key_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_backed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(hw_backed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exportable) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(exportable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security_level) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(security_level)
        )
    );
}
#[doc = " Struct to represent the configuration of a blinded key."]
pub type crypto_key_config_t = crypto_key_config;
#[doc = " Struct to handle unmasked key type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_unblinded_key {
    pub key_mode: key_mode_t,
    pub key_length: usize,
    pub key: *mut u32,
    pub checksum: u32,
}
#[test]
fn bindgen_test_layout_crypto_unblinded_key() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_unblinded_key> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_unblinded_key>(),
        32usize,
        concat!("Size of: ", stringify!(crypto_unblinded_key))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_unblinded_key>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_unblinded_key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_unblinded_key),
            "::",
            stringify!(key_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_unblinded_key),
            "::",
            stringify!(key_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_unblinded_key),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_unblinded_key),
            "::",
            stringify!(checksum)
        )
    );
}
#[doc = " Struct to handle unmasked key type."]
pub type crypto_unblinded_key_t = crypto_unblinded_key;
#[doc = " Struct to handle masked key type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_blinded_key {
    pub config: crypto_key_config_t,
    pub keyblob_length: usize,
    pub keyblob: *mut u32,
    pub checksum: u32,
}
#[test]
fn bindgen_test_layout_crypto_blinded_key() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_blinded_key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_blinded_key>(),
        56usize,
        concat!("Size of: ", stringify!(crypto_blinded_key))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_blinded_key>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_blinded_key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_blinded_key),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyblob_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_blinded_key),
            "::",
            stringify!(keyblob_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyblob) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_blinded_key),
            "::",
            stringify!(keyblob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_blinded_key),
            "::",
            stringify!(checksum)
        )
    );
}
#[doc = " Struct to handle masked key type."]
pub type crypto_blinded_key_t = crypto_blinded_key;
pub const hash_mode_kHashModeSha256: hash_mode = 1691;
pub const hash_mode_kHashModeSha384: hash_mode = 1966;
pub const hash_mode_kHashModeSha512: hash_mode = 369;
pub const hash_mode_kHashModeSha3_224: hash_mode = 1302;
pub const hash_mode_kHashModeSha3_256: hash_mode = 724;
pub const hash_mode_kHashModeSha3_384: hash_mode = 615;
pub const hash_mode_kHashModeSha3_512: hash_mode = 1101;
pub const hash_mode_kHashXofModeShake128: hash_mode = 1496;
pub const hash_mode_kHashXofModeShake256: hash_mode = 842;
pub const hash_mode_kHashXofModeCshake128: hash_mode = 189;
pub const hash_mode_kHashXofModeCshake256: hash_mode = 1250;
#[doc = " Enum to define supported hashing modes.\n\n Values are hardened."]
pub type hash_mode = ::core::ffi::c_uint;
#[doc = " Enum to define supported hashing modes.\n\n Values are hardened."]
pub use self::hash_mode as hash_mode_t;
#[doc = " Container for a hash digest."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hash_digest {
    pub mode: hash_mode_t,
    pub len: usize,
    pub data: *mut u32,
}
#[test]
fn bindgen_test_layout_hash_digest() {
    const UNINIT: ::core::mem::MaybeUninit<hash_digest> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hash_digest>(),
        24usize,
        concat!("Size of: ", stringify!(hash_digest))
    );
    assert_eq!(
        ::core::mem::align_of::<hash_digest>(),
        8usize,
        concat!("Alignment of ", stringify!(hash_digest))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_digest),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_digest),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_digest),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Container for a hash digest."]
pub type hash_digest_t = hash_digest;
#[doc = " Generic hash context.\n\n Representation is internal to the hash implementation; initialize\n with #otcrypto_hash_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hash_context {
    pub mode: hash_mode_t,
    pub data: [u32; 52usize],
}
#[test]
fn bindgen_test_layout_hash_context() {
    const UNINIT: ::core::mem::MaybeUninit<hash_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hash_context>(),
        212usize,
        concat!("Size of: ", stringify!(hash_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hash_context>(),
        4usize,
        concat!("Alignment of ", stringify!(hash_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_context),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_context),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Generic hash context.\n\n Representation is internal to the hash implementation; initialize\n with #otcrypto_hash_init."]
pub type hash_context_t = hash_context;
extern "C" {
    #[doc = " Performs the required hash function on the input data.\n\n The caller should allocate space for the `digest` buffer and set the `mode`\n and `len` fields. If the length does not match the mode, an error message\n will be returned.\n\n This function should only be used for fixed-length hash functions (SHA-2 and\n SHA-3 families). Use `otcrypto_xof_shake` and `otcrypto_xof_cshake` for\n extendable-output functions.\n\n @param input_message Input message to be hashed.\n @param[out] digest Output digest after hashing the input message.\n @return Result of the hash operation."]
    pub fn otcrypto_hash(
        input_message: crypto_const_byte_buf_t,
        digest: *mut hash_digest_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the SHAKE extendable output function (XOF) on input data.\n\n The caller should allocate space for the `digest` buffer and set the `mode`\n and `len` fields.  The `mode` parameter must be `kHashXofModeShake128` or\n `kHashXofModeShake256`; other values will result in errors.\n\n @param input_message Input message for extendable output function.\n @param[out] digest Output from the extendable output function.\n @return Result of the xof operation."]
    pub fn otcrypto_xof_shake(
        input_message: crypto_const_byte_buf_t,
        digest: *mut hash_digest_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the CSHAKE extendable output function (XOF) on input data.\n\n The `function_name_string` is used by NIST to define functions based on\n cSHAKE. When no function other than cSHAKE is desired; it can be empty. The\n `customization_string` is used to define a variant of the cSHAKE function.\n If no customization is desired it can be empty.\n\n The caller should allocate space for the `digest` buffer and set the `mode`\n and `len` fields. The `mode` parameter must be `kHashXofModeCshake128` or\n `kHashXofModeCshake256`; other values will result in errors.\n\n @param input_message Input message for extendable output function.\n @param function_name_string NIST Function name string.\n @param customization_string Customization string for cSHAKE.\n @param[out] digest Output from the extendable output function.\n @return Result of the xof operation."]
    pub fn otcrypto_xof_cshake(
        input_message: crypto_const_byte_buf_t,
        function_name_string: crypto_const_byte_buf_t,
        customization_string: crypto_const_byte_buf_t,
        digest: *mut hash_digest_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the INIT operation for a cryptographic hash function.\n\n Initializes the generic hash context. The required hash mode is selected\n through the `hash_mode` parameter. Only `kHashModeSha256`, `kHashModeSha384`\n and `kHashModeSha512` are supported. Other modes are not supported and an\n error would be returned.\n\n Populates the hash context with the selected hash mode and its digest and\n block sizes. The structure of hash context and how it populates the required\n fields are internal to the specific hash implementation.\n\n @param ctx Pointer to the generic hash context struct.\n @param hash_mode Required hash mode.\n @return Result of the hash init operation."]
    pub fn otcrypto_hash_init(ctx: *mut hash_context_t, hash_mode: hash_mode_t) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the UPDATE operation for a cryptographic hash function.\n\n The update operation processes the `input_message` using the selected hash\n compression function. The intermediate digest is stored in the context\n `ctx`. Any partial data is stored back in the context and combined with the\n subsequent bytes.\n\n #otcrypto_hash_init should be called before this function.\n\n @param ctx Pointer to the generic hash context struct.\n @param input_message Input message to be hashed.\n @return Result of the hash update operation."]
    pub fn otcrypto_hash_update(
        ctx: *mut hash_context_t,
        input_message: crypto_const_byte_buf_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the FINAL operation for a cryptographic hash function.\n\n The final operation processes the remaining partial blocks, computes the\n final hash and copies it to the `digest` parameter.\n\n #otcrypto_hash_update should be called before this function.\n\n The caller should allocate space for the `digest` buffer and set the `mode`\n and `len` fields. If the `mode` doesn't match the mode of the hash context,\n the function will return an error.\n\n @param ctx Pointer to the generic hash context struct.\n @param[out] digest Output digest after hashing the input blocks.\n @return Result of the hash final operation."]
    pub fn otcrypto_hash_final(
        ctx: *mut hash_context_t,
        digest: *mut hash_digest_t,
    ) -> crypto_status_t;
}
pub const kmac_mode_kMacModeKmac128: kmac_mode = 822;
pub const kmac_mode_kMacModeKmac256: kmac_mode = 3780;
#[doc = " Enum to define KMAC mode.\n\n Values are hardened."]
pub type kmac_mode = ::core::ffi::c_uint;
#[doc = " Enum to define KMAC mode.\n\n Values are hardened."]
pub use self::kmac_mode as kmac_mode_t;
#[doc = " Generic hmac context.\n\n Representation is internal to the hmac implementation; initialize\n with #otcrypto_hmac_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_context {
    pub inner: hash_context_t,
    pub outer: hash_context_t,
}
#[test]
fn bindgen_test_layout_hmac_context() {
    const UNINIT: ::core::mem::MaybeUninit<hmac_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hmac_context>(),
        424usize,
        concat!("Size of: ", stringify!(hmac_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hmac_context>(),
        4usize,
        concat!("Alignment of ", stringify!(hmac_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(inner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outer) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(outer)
        )
    );
}
#[doc = " Generic hmac context.\n\n Representation is internal to the hmac implementation; initialize\n with #otcrypto_hmac_init."]
pub type hmac_context_t = hmac_context;
extern "C" {
    #[doc = " Performs the HMAC function on the input data.\n\n This function computes the HMAC function on the `input_message` using the\n `key` and returns a `tag`. The key should be at least as long as the digest\n for the chosen hash function. The hash function is determined by the key\n mode. Only SHA-2 hash functions are supported. Other modes (e.g. SHA-3) are\n not supported and will result in errors.\n\n The caller should allocate 32 bytes (8 32-bit words) of space for the `tag`\n buffer and set its `len` field to 8.\n\n @param key Pointer to the blinded key struct with key shares.\n @param input_message Input message to be hashed.\n @param[out] tag Output authentication tag.\n @return The result of the HMAC operation."]
    pub fn otcrypto_hmac(
        key: *const crypto_blinded_key_t,
        input_message: crypto_const_byte_buf_t,
        tag: *mut crypto_word32_buf_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the KMAC function on the input data.\n\n This function computes the KMAC on the `input_message` using the `key` and\n returns a `tag` of `required_output_len`. The customization string is passed\n through `customization_string` parameter. If no customization is desired it\n can be empty.\n\n The caller should allocate enough space in the `tag` buffer to hold\n `required_output_len` bytes, rounded up to the nearest word, and then set\n the `len` field of `tag` to the word length. If the word length is not long\n enough to hold `required_output_len` bytes, then the function will return an\n error.\n\n @param key Pointer to the blinded key struct with key shares.\n @param input_message Input message to be hashed.\n @param mac_mode Required KMAC mode.\n @param customization_string Customization string.\n @param required_output_len Required output length, in bytes.\n @param[out] tag Output authentication tag.\n @return The result of the KMAC operation."]
    pub fn otcrypto_kmac(
        key: *const crypto_blinded_key_t,
        input_message: crypto_const_byte_buf_t,
        kmac_mode: kmac_mode_t,
        customization_string: crypto_const_byte_buf_t,
        required_output_len: usize,
        tag: *mut crypto_word32_buf_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the INIT operation for HMAC.\n\n Initializes the HMAC context. The key should be at least as long as the\n digest for the chosen hash function. The hash function is determined by the\n key mode. Only SHA-2 hash functions are are supported. Other modes (e.g.\n SHA-3) are not supported and will result in errors.\n\n @param[out] ctx Pointer to the generic HMAC context struct.\n @param key Pointer to the blinded HMAC key struct.\n @param hash_mode Hash function to use.\n @return Result of the HMAC init operation."]
    pub fn otcrypto_hmac_init(
        ctx: *mut hmac_context_t,
        key: *const crypto_blinded_key_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the UPDATE operation for HMAC.\n\n The update operation processes the `input_message` using the selected\n compression function. The intermediate state is stored in the HMAC context\n `ctx`. Any partial data is stored back in the context and combined with the\n subsequent bytes.\n\n #otcrypto_hmac_init should be called before calling this function.\n\n @param ctx Pointer to the generic HMAC context struct.\n @param input_message Input message to be hashed.\n @return Result of the HMAC update operation."]
    pub fn otcrypto_hmac_update(
        ctx: *mut hmac_context_t,
        input_message: crypto_const_byte_buf_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the FINAL operation for HMAC.\n\n The final operation processes the remaining partial blocks, computes the\n final authentication code and copies it to the `tag` parameter.\n\n #otcrypto_hmac_update should be called before calling this function.\n\n The caller should allocate space for the `tag` buffer, (the length should\n match the hash function digest size), and set the length of expected output\n in the `len` field of `tag`. If the user-set length and the output length\n does not match, an error message will be returned.\n\n @param ctx Pointer to the generic HMAC context struct.\n @param[out] tag Output authentication tag.\n @return Result of the HMAC final operation."]
    pub fn otcrypto_hmac_final(
        ctx: *mut hmac_context_t,
        tag: *mut crypto_word32_buf_t,
    ) -> crypto_status_t;
}
#[doc = " Number of 32-bit words for the salt."]
pub const kKeymgrSaltNumWords: _bindgen_ty_1 = 8;
#[doc = " Number of 32-bit words for each output key share."]
pub const kKeymgrOutputShareNumWords: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
#[doc = " Data used to differentiate a generated keymgr key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keymgr_diversification {
    #[doc = " Salt value to use for key generation."]
    pub salt: [u32; 8usize],
    #[doc = " Version for key generation (anti-rollback protection)."]
    pub version: u32,
}
#[test]
fn bindgen_test_layout_keymgr_diversification() {
    const UNINIT: ::core::mem::MaybeUninit<keymgr_diversification> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<keymgr_diversification>(),
        36usize,
        concat!("Size of: ", stringify!(keymgr_diversification))
    );
    assert_eq!(
        ::core::mem::align_of::<keymgr_diversification>(),
        4usize,
        concat!("Alignment of ", stringify!(keymgr_diversification))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).salt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keymgr_diversification),
            "::",
            stringify!(salt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(keymgr_diversification),
            "::",
            stringify!(version)
        )
    );
}
#[doc = " Data used to differentiate a generated keymgr key."]
pub type keymgr_diversification_t = keymgr_diversification;
#[doc = " Generated key from keymgr.\n\n The output key material is 256 bits, generated in two shares."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keymgr_output {
    pub share0: [u32; 8usize],
    pub share1: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_keymgr_output() {
    const UNINIT: ::core::mem::MaybeUninit<keymgr_output> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<keymgr_output>(),
        64usize,
        concat!("Size of: ", stringify!(keymgr_output))
    );
    assert_eq!(
        ::core::mem::align_of::<keymgr_output>(),
        4usize,
        concat!("Alignment of ", stringify!(keymgr_output))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).share0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keymgr_output),
            "::",
            stringify!(share0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).share1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(keymgr_output),
            "::",
            stringify!(share1)
        )
    );
}
#[doc = " Generated key from keymgr.\n\n The output key material is 256 bits, generated in two shares."]
pub type keymgr_output_t = keymgr_output;
extern "C" {
    #[doc = " Derive a key manager key that is visible to software.\n\n @param diversification Diversification input for the key derivation.\n @param[out] key Destination key struct.\n @return OK or error."]
    pub fn keymgr_generate_key_sw(
        diversification: keymgr_diversification_t,
        key: *mut keymgr_output_t,
    ) -> status_t;
}
extern "C" {
    #[doc = " Derive a key manager key for the AES block.\n\n Calls the key manager to sideload a key into the AES hardware block and\n waits until the operation is complete before returning.\n\n @param diversification Diversification input for the key derivation.\n @return OK or error."]
    pub fn keymgr_generate_key_aes(diversification: keymgr_diversification_t) -> status_t;
}
extern "C" {
    #[doc = " Derive a key manager key for the KMAC block.\n\n Calls the key manager to sideload a key into the KMAC hardware block and\n waits until the operation is complete before returning.\n\n @param diversification Diversification input for the key derivation.\n @return OK or error."]
    pub fn keymgr_generate_key_kmac(diversification: keymgr_diversification_t) -> status_t;
}
extern "C" {
    #[doc = " Derive a key manager key for the OTBN block.\n\n Calls the key manager to sideload a key into the OTBN hardware block and\n waits until the operation is complete before returning.\n\n @param diversification Diversification input for the key derivation.\n @return OK or error."]
    pub fn keymgr_generate_key_otbn(diversification: keymgr_diversification_t) -> status_t;
}
extern "C" {
    #[doc = " Clear the sideloaded AES key.\n\n @return OK or error."]
    pub fn keymgr_sideload_clear_aes() -> status_t;
}
extern "C" {
    #[doc = " Clear the sideloaded KMAC key.\n\n @return OK or error."]
    pub fn keymgr_sideload_clear_kmac() -> status_t;
}
extern "C" {
    #[doc = " Clear the sideloaded OTBN key.\n\n @return OK or error."]
    pub fn keymgr_sideload_clear_otbn() -> status_t;
}
extern "C" {
    #[doc = " Get the word-length of the full blinded keyblob for a given key length.\n\n @param config Key configuration.\n @returns Word-length of the blinded keyblob."]
    pub fn keyblob_num_words(config: crypto_key_config_t) -> usize;
}
extern "C" {
    #[doc = " Get the word-length of a single key share for a given key length.\n\n Essentially, this just rounds `config.key_length` up to the next word.\n The results assume that the key is not hardware-backed, since\n hardware-backed keys do not have shares within the keyblob.\n\n @param config Key configuration.\n @returns Word-length of one key share (or unblinded key)."]
    pub fn keyblob_share_num_words(config: crypto_key_config_t) -> usize;
}
extern "C" {
    #[doc = " Return pointers to the separate shares within the blinded key.\n\n Returns an error if the keyblob length does not match the expectations from\n the key configuration.\n\n @param key Blinded key from which to extract shares.\n @param[out] share0 Pointer to direct to the first share.\n @param[out] share1 Pointer to direct to the second share.\n @return Result of the operation."]
    pub fn keyblob_to_shares(
        key: *const crypto_blinded_key_t,
        share0: *mut *mut u32,
        share1: *mut *mut u32,
    ) -> status_t;
}
extern "C" {
    #[doc = " Construct a blinded keyblob from the given shares.\n\n The size of each share should be at least `key_len` rounded up to the next\n word (so if `key_len` is 10 bytes, each share should be 3 words or 12\n bytes). The size of the destination buffer should be sufficient to fit\n both shares; if `key_len` is 10 bytes, it must have 6 words, even though\n 20 bytes would technically fit in 5. This is to preserve word-alignment of\n the shares.\n\n @param share0 First share.\n @param share1 Second share.\n @param config Key configuration.\n @param[out] keyblob Destination buffer."]
    pub fn keyblob_from_shares(
        share0: *const u32,
        share1: *const u32,
        config: crypto_key_config_t,
        keyblob: *mut u32,
    );
}
extern "C" {
    #[doc = " Construct key manager diversification data from a blinded key.\n\n The keyblob for a hardware-backed key must be exactly 8 32-bit words long.\n The first word is the version and subsequent words are the salt. The key\n mode is appended to the salt to prevent key manager keys being used for\n different modes.\n\n If the key configuration states that the key is not hardware-backed, or if\n the keyblob is the wrong length, this function will return an error.\n\n @param key Blinded key to use.\n @param[out] Destination key manager diversification struct."]
    pub fn keyblob_to_keymgr_diversification(
        key: *const crypto_blinded_key_t,
        diversification: *mut keymgr_diversification_t,
    ) -> status_t;
}
extern "C" {
    #[doc = " Checks that the configuration represents a key masked with XOR.\n\n Returns false if the key is for an algorithm that uses a different masking\n method (e.g. arithmetic masking for asymmetric crypto) or if the key is\n hardware-backed.\n\n @param config Key configuration.\n @return OK if `config` represents an XOR-masked key, BAD_ARGS otherwise."]
    pub fn keyblob_ensure_xor_masked(config: crypto_key_config_t) -> status_t;
}
extern "C" {
    #[doc = " Construct a blinded keyblob from the given key and mask.\n\n The size of the key and mask should be `key_len` rounded up to the next\n word (so if `key_len` is 10 bytes, each share should be 3 words or 12\n bytes). The size of the destination buffer should be sufficient to fit\n both shares; if `key_len` is 10 bytes, it must have 6 words, even though\n 20 bytes would technically fit in 5. This is to preserve word-alignment of\n the shares.\n\n Returns an error if called for an asymmetric key configuration; asymmetric\n keys are likely to be masked with arithmetic rather than boolean (XOR)\n schemes, and this function cannot be used for them.\n\n @param key Plaintext key.\n @param mask Blinding value.\n @param config Key configuration.\n @param[out] keyblob Destination buffer.\n @return Result of the operation."]
    pub fn keyblob_from_key_and_mask(
        key: *const u32,
        mask: *const u32,
        config: crypto_key_config_t,
        keyblob: *mut u32,
    ) -> status_t;
}
extern "C" {
    #[doc = " Incorporate a fresh mask into the blinded key.\n\n Returns an error if called for an asymmetric key configuration; asymmetric\n keys are likely to be masked with arithmetic rather than boolean (XOR)\n schemes, and this function cannot be used for them.\n\n @param key Blinded key to re-mask. Modified in-place.\n @param mask Blinding parameter (fresh random mask).\n @return Result of the operation."]
    pub fn keyblob_remask(key: *mut crypto_blinded_key_t, mask: *const u32) -> status_t;
}
extern "C" {
    #[doc = " Compute the checksum of an unblinded key.\n\n The current key checksum is ignored. Call this routine after modifying\n blinded key material (e.g. for re-masking).\n\n @param key Unblinded key.\n @returns Checksum value."]
    pub fn integrity_unblinded_checksum(key: *const crypto_unblinded_key_t) -> u32;
}
extern "C" {
    #[doc = " Compute the checksum of a blinded key.\n\n The current key checksum is ignored. Call this routine after modifying\n blinded key material (e.g. for re-masking).\n\n @param key Blinded key.\n @returns Checksum value."]
    pub fn integrity_blinded_checksum(key: *const crypto_blinded_key_t) -> u32;
}
extern "C" {
    #[doc = " Perform an integrity check on the unblinded key.\n\n Returns `kHardenedBoolTrue` if the check passed and `kHardenedBoolFalse`\n otherwise.\n\n @param key Unblinded key.\n @returns Whether the integrity check passed."]
    pub fn integrity_unblinded_key_check(key: *const crypto_unblinded_key_t) -> hardened_bool_t;
}
extern "C" {
    #[doc = " Perform an integrity check on the blinded key.\n\n Returns `kHardenedBoolTrue` if the check passed and `kHardenedBoolFalse`\n otherwise.\n\n @param key Blinded key.\n @returns Whether the integrity check passed."]
    pub fn integrity_blinded_key_check(key: *const crypto_blinded_key_t) -> hardened_bool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
